# ADR: Выбор веб-фреймворка для реализации экспертной системы

**Статус:** Принято

## Контекст и формулировка проблемы
Экспертная система использует две базы данных разного типа: реляционную PostgreSQL и графовую Neo4j. Необходим веб-фреймворк, позволяющий реализовать сложные алгоритмы обхода графа, обеспечить прозрачность и управляемость логики приложения, интегрировать разные источники данных и минимизировать накладные зависимости.

## Драйверы решения
- Реализация сложных алгоритмов навигации по графу и обработки данных без ограничений фреймворка.  
- Гибкость архитектуры и возможность внесения изменений в бизнес-логику без монолитных ограничений. 
- Минимизация избыточных компонентов и зависимостей для повышения управляемости кода.  

## Рассмотренные варианты
- **Django**: Многофункциональный фреймворк с жесткими соглашениями и встроенными компонентами. Ограничивает свободу архитектурных решений и усложняет интеграцию с графовыми базами для реализации алгоритмов обхода.  
- **Flask**: Микрофреймворк с минимальным ядром, позволяющий строить произвольную архитектуру, реализовывать сложные алгоритмы обхода графа и интегрировать различные базы данных без ограничений.  
- **FastAPI**: Высокопроизводительный фреймворк для API с автоматической документацией. Эффективен для REST и реального времени, но менее удобен для серверной генерации интерфейсов с пошаговой логикой.  
- **Ruby on Rails**:  Фреймворк ориентирован на использование встроенных компонентов, таких как ORM ActiveRecord, маршрутизация и генераторы scaffold. Такая тесная интеграция упрощает стандартные CRUD-приложения, но ограничивает гибкость архитектуры и усложняет внедрение нестандартных алгоритмов. В частности, интеграция с графовыми базами данных для реализации обхода графа требует обходных решений и снижает управляемость логики интеллектуальной системы.
- **PHP (Laravel)**: Архитектура фреймворка ориентирована на реляционные базы и типовые веб-паттерны. Интеграция с Neo4j требует сторонних библиотек и абстракций, что усложняет реализацию алгоритмов обхода графа и снижает прозрачность кода. 

## Результат решения
**Выбранный вариант:** "Flask", так как он обеспечивает максимальную гибкость при реализации алгоритмов, свободную организацию архитектуры и минимизацию избыточных компонентов. Другие варианты ограничивают возможности по интеграции с графовой базой или усложняют реализацию логики экспертной системы.

## Последствия

**Положительные**
- Полная свобода реализации алгоритмов обхода графа и обработки данных.  
- Гибкая архитектура, независимая от ограничений фреймворка.  
- Простая интеграция с Python-библиотеками для работы над данными.  
- Минимальные накладные зависимости, легковесность приложения.  

**Отрицательные**
- Отсутствие встроенных компонентов (ORM, аутентификация, админ-панель) требует их реализации вручную.  
- Более высокая ответственность за проектирование архитектуры и маршрутизации.  
- Меньшая автоматизация стандартных веб-задач по сравнению с Django или Rails.
